import * as crypto from 'crypto';
const webcrypto = crypto.webcrypto;
export default webcrypto;
export function isCryptoKey(key) {
    if (webcrypto !== undefined) {
        return key instanceof webcrypto.CryptoKey;
    }
    return false;
}
function getHashLength(hash) {
    return parseInt(hash === null || hash === void 0 ? void 0 : hash.name.substr(4), 10);
}
function getNamedCurve(alg) {
    switch (alg) {
        case 'ES256':
            return 'P-256';
        case 'ES384':
            return 'P-384';
        case 'ES512':
            return 'P-521';
    }
}
export function getKeyObject(key, alg, usage) {
    if (!alg) {
        return crypto.KeyObject.from(key);
    }
    if (usage && !key.usages.find(Set.prototype.has.bind(usage))) {
        throw new TypeError('CryptoKey does not support this operation');
    }
    switch (alg) {
        case 'HS256':
        case 'HS384':
        case 'HS512':
            if (key.algorithm.name !== 'HMAC' ||
                getHashLength(key.algorithm.hash) !== parseInt(alg.substr(2), 10)) {
                throw new TypeError('CryptoKey does not support this operation');
            }
            break;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            if (key.algorithm.name !== 'RSASSA-PKCS1-v1_5' ||
                getHashLength(key.algorithm.hash) !== parseInt(alg.substr(2), 10)) {
                throw new TypeError('CryptoKey does not support this operation');
            }
            break;
        case 'PS256':
        case 'PS384':
        case 'PS512':
            if (key.algorithm.name !== 'RSA-PSS' ||
                getHashLength(key.algorithm.hash) !== parseInt(alg.substr(2), 10)) {
                throw new TypeError('CryptoKey does not support this operation');
            }
            break;
        case 'ES256':
        case 'ES384':
        case 'ES512':
            if (key.algorithm.name !== 'ECDSA' ||
                key.algorithm.namedCurve !== getNamedCurve(alg)) {
                throw new TypeError('CryptoKey does not support this operation');
            }
            break;
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            if (key.algorithm.name !== 'AES-GCM' ||
                key.algorithm.length !== parseInt(alg.substr(1, 3), 10)) {
                throw new TypeError('CryptoKey does not support this operation');
            }
            break;
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
            if (key.algorithm.name !== 'AES-KW' ||
                key.algorithm.length !== parseInt(alg.substr(1, 3), 10)) {
                throw new TypeError('CryptoKey does not support this operation');
            }
            break;
        case 'ECDH-ES':
            if (key.algorithm.name !== 'ECDH') {
                throw new TypeError('CryptoKey does not support this operation');
            }
            break;
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW':
            if (key.algorithm.name !== 'PBKDF2') {
                throw new TypeError('CryptoKey does not support this operation');
            }
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            if (key.algorithm.name !== 'RSA-OAEP' ||
                getHashLength(key.algorithm.hash) !==
                    (parseInt(alg.substr(9), 10) || 1)) {
                throw new TypeError('CryptoKey does not support this operation');
            }
            break;
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    return crypto.KeyObject.from(key);
}
